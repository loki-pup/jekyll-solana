---
title: Django Demo Project
teaser: web development
category: Django
tags: [web development]
---

### Flow:

HTTP Request -> urls.py -> forward request to view: views.py -> HTTP Response (HTML)

models.py <-> read / write data views.py

Template (<filename>.html) -> views.py

* View: A view is a request handler function, which receives HTTP requests and returns HTTP responses

* Templates: A template is a text file defining the structure or layout of a file (such as an HTML page), with placeholders used to represent actual content

## Create the project

```
django-admin startproject locallibrary
```

It has the following structure:
```
locallibrary/
    manage.py
    locallibrary/
        __init__.py
        settings.py
        urls.py
        wsgi.py
        asgi.py
```

## Create the catalog application

Make sure to run this command from the same folder as your project's manage.py:

```
py -3 manage.py startapp catalog
```

update structure:
```
locallibrary/
    manage.py
    locallibrary/
    catalog/
        admin.py
        apps.py
        models.py
        tests.py
        views.py
        __init__.py
        migrations/
```

## Register the catalog application

We have to register it with the project so that it will be included when any tools are run (like adding models to the database for example). 

Applications are registered by adding them to the `INSTALLED_APPS` list in the project settings.

```
 # Add our new application
    'catalog.apps.CatalogConfig', # This object was created for us in /catalog/apps.py
```    

> A django App is a fancy name for a python package. Really, that's it. The only thing that would distinguish a django app from other python packages is that it makes sense for it to appear in the INSTALLED_APPS list in settings.py, because it contains things like templates, models, or other features that can be auto-discovered by other django features.

from [What exactly are Django Apps](https://stackoverflow.com/questions/7276011/what-exactly-are-django-apps)

## Specify the database

You can see how this database is configured in settings.py:

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

## Other project settings

The settings.py file is also used for configuring a number of other settings, but at this point, you probably only want to change the TIME_ZONE

```
TIME_ZONE = 'Hongkong'
```

* SECRET_KEY. This is a secret key that is used as part of Django's website security strategy. If you're not protecting this code in development, you'll need to use a different code (perhaps read from an environment variable or file) when putting it into production.

* DEBUG. This enables debugging logs to be displayed on error, rather than HTTP status code responses. This should be set to False in production as debug information is useful for attackers, but for now we can keep it set to True.

## Hook up the URL mapper

The website is created with a URL mapper file (urls.py) in the project folder. While you can use this file to manage all your URL mappings, it is more usual to **defer mappings to the associated application**.

```
The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
```

This new item includes a **path() that forwards requests with the pattern catalog/ to the module catalog.urls** (the file with the relative URL catalog/urls.py).

```
# Use include() to add paths from the catalog application
from django.urls import include

urlpatterns += [
    path('catalog/', include('catalog.urls')),
]
```

Now let's redirect the root URL of our site (i.e. 127.0.0.1:8000) to the URL 127.0.0.1:8000/catalog/. This is the **only app** we'll be using in this project. 

To do this, we'll use a special view function, RedirectView, which takes the new relative URL to redirect to (/catalog/) as its first argument when the URL pattern specified in the path() function is matched (the root URL, in this case).

```
# Add URL maps to redirect the base URL to our application
from django.views.generic import RedirectView
urlpatterns += [
    path('', RedirectView.as_view(url='catalog/', permanent=True)),
]
```

Leave the first parameter of the path function empty to imply '/'. If you write the first parameter as '/' Django will give you the following warning when you start the development server:

```
System check identified some issues:

WARNINGS:
?: (urls.W002) Your URL pattern '/' has a route beginning with a '/'.
Remove this slash as it is unnecessary.
If this pattern is targeted in an include(), ensure the include() pattern has a trailing '/'.
```

Django does not serve static files like CSS, JavaScript, and images by default, but it can be useful for the development web server to do so while you're creating your site. As a final addition to this URL mapper, you can enable the serving of static files during development by appending the following lines.

Django does not serve static files like CSS, JavaScript, and images by default, but it can be useful for the development web server to do so while you're creating your site. You can enable the serving of static files during development by appending the following lines.

```
# Use static() to add URL mapping to serve static files during development (only)
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

As a final step, create a file inside your catalog folder called urls.py, and add the following text to define the (empty) imported urlpatterns. This is where we'll add our patterns as we build the application.

```
from django.urls import path
from . import views

urlpatterns = [

]
```

## Test the website framework

Before we run the server, we should first run a database migration. This updates our database (to include any models in our installed applications) and removes some build warnings.

### Run database migrations

Django uses an Object-Relational-Mapper (ORM) to map model definitions in the Django code to the data structure used by the underlying database. As we change our model definitions, Django tracks the changes and can create database migration scripts (in /django-locallibrary-tutorial/catalog/migrations/) to automatically migrate the underlying data structure in the database to match the model.

make sure you are in the directory that contains manage.py

```
py -3 manage.py makemigrations
py -3 manage.py migrate
```

> **Warning:** You'll need to run these commands every time your models change in a way that will affect the structure of the data that needs to be stored (including both addition and removal of whole models and individual fields).

### Run the website
During development, you can serve the website first using the development web server, and then viewing it on your local web browser.

> Note: The development web server is not robust or performant enough for production use, but for a convenient quick test. By default it will serve the site to your local computer (http://127.0.0.1:8000/), but you can also specify other computers on your network to serve to.

```
py -3 manage.py runserver
```

## Design the LocalLibrary models

Django web applications access and manage data through Python objects referred to as models. Models define the structure of stored data, including the field types and possibly also their maximum size, default values, selection list options, help text for documentation, label text for forms, etc. The definition of the model is independent of the underlying database — you can choose one of several as part of your project settings. Once you've chosen what database you want to use, you don't need to talk to it directly at all — you just write your model structure and other code, and Django handles all the dirty work of communicating with the database for you.

## Model primer

### Model definition

Models are usually defined in an application's models.py file. They are implemented as subclasses of django.db.models.Model, and can include fields, methods and metadata. 

### Fields

A model can have an arbitrary number of fields, of any type — each one represents a column of data that we want to store in one of our database tables.

```
my_field_name = models.CharField(max_length=20, help_text='Enter field documentation')
```

* max_length=20 — States that the maximum length of a value in this field is 20 characters.

* help_text='Enter field documentation' — helpful text that may be displayed in a form to help users understand how the field is used.

The field name is used to refer to it in queries and templates. Fields also have a **label**, which is specified using the **verbose_name** argument (with a default value of None). If verbose_name is not set, the label is created from the field name by **replacing any underscores with a space, and capitalizing the first letter** (for example, the field my_field_name would have a **default label of My field name** when used in forms).